## 참조 지역성

캐시 메모리는 프로세서 코어가 로컬 방식으로 메모리 시스템에 접근한다는 가정하에 작동한다.

'자주 참조되는 데이터'에 대한 판단은 '지역성의 원리'를 따르며, 이 지역성을 두 가지 유형으로 구분한다.

- 시간 지역성 : 최근 접근한 데이터가 다시 접근할 가능성이 높다. (Ex: 루프 로직)
- 공간 지역성 : 접근한 데이터에 가까운 주소에 접근할 가능성이 높다. (Ex: 배열)

## 메모리 조각화

두 가지 유형의 단편화를 통해서 메모리 조각화 현상을 알아보자.

### 함수기반의 조각화

부모 함수가 자식 함수를 호출하는 경우, 다음 두 가지 이유로 인한 결함이 존재한다.
- 자식 함수의 코드가 캐시에 존재하지 않는 경우, 'Cache Miss'가 발생하여 프로세서가 중지된다.
- 흐름 변경이 발생하면, 파이프라인을 'Flush'해야하므로 사이클에 상당한 결함이 발생할 수 있다.

### 코드 기반 조각화

함수에는 종종 코너 케이스들, 시행되지 않는 케이스의 코드가 포함되어있다. 이는 캐시 사용률 감소의 결과를 만들어내며, Cache Miss 현상이 발생할 수 있다.


## 코드 최적화 가이드라인

### Runtime vs. Initializtion / Corner-Case code

무엇보다도 먼저 런타임 코드(자주 호출되는 코드)와 초기화/코너 케이스 코드 간에 코드를 명확하게 구분해야 한다.

런타임 코드는 알고리즘을 시행할 때마다 실행될 수 있는 중요한 코드만 포함해야한다. 런타임 코드에서 코너 케이스 코드를 제거하면, 동적 메모리 공간이 최소화된다.

### Linker Optimiztion / Code Positioning

함수를 임이의 순서대로 링크하면 안된다. 개발자는 적어도 런타임 코드에 대해서는 수행되는 함수들의 순서를 생각해야 한다. 이를 위해 알고리즘의 실시간 함수 호출 흐름을 고려해야 한다.

### 코드 파티셔닝

코드 파티셔닝은 코드를 재구성하여 코드 기반의 조각화를 줄여준다. 아래의 코드를 살펴보자.

```c
void foo() {
	if(condition){
		//something
	} else {
		//something2
	}
	return value;
}
```

코어는 두 개의 코드 블록 중 하나인 something, 또는 something2를 실행한다. 공간 지역성을 가정하여 작동하면, 캐시는 두 블록의 코드를 모두 저장할 수 있다.

만약 something이 매우 높은 확률로 실행되고 something2가 매우 드물게 실행되면 동적 메모리의 크기가 불필요하게 커져 캐시 활용도가 낮아진다. 아래 코드를 또 살펴보자.

```c
void foo() {
	if(condition) {
		//something
	} else {
		something2_code();
	}
	return value;
}
```

이 경우 드물게 something2_code라고 불리는 자체 지역함수가 수행된다. 이 함수의 코드는 메모리의 다른 곳에 위치하기 때문에 공간 지역성은 더 이상 두 블록의 코드에서 강제되지 않는다. 이렇게 하면 동적 메모리 설치 공간이 줄어들어 캐시 사용률이 높아진다.

동일한 방식으로, 케이스 문이 많은 스위치(Switch) 문에도 적용 가능하다.

> 많은 케이스가 존재하는 큰 함수를 가지고 있다면, 어떤 케이스가 자주 실행될 것인지 따져보고, 자주 실행되지 않는 케이스에서 다른 함수를 호출한다.

### 인라이닝

인라이닝은 함수 기반의 메모리 조각화를 줄이는데 유용하다.

한 함수를 다른 함수에 포함시킴으로써 흐름 변화를 줄이고 코드를 더 선형적으로 만든다.

하지만 단점이 있는데, 코드 자체의 크기가 커진다는 것이고, 이는 때때로 역효과를 가져올 수 있다. 다음 체크리스트를 참고하여 인라이닝 함수를 가져올지 판단해보자.

- 함수의 크기는 어떻게 되는지
- 그 함수를 호출하는 장소가 몇 개나 되는지
- 함수가 자주 호출되는지? 아니면 코너 케이스인지?

### 정렬

캐시에서 함수 유효 크기는 메모리 정렬에 따라 달라질 수 있다. 함수가 캐시 라인 1개 보다 약간 큰 크기의 메모리를 필요로 한다고 가정해 보자. 이 경우 함수는 두 개의 캐시 라인을 할당해야 하므로 유효 크기가 크게 증가한다. 따라서 함수를 캐시 라인 바운더리에 맞추는 것이 낭비되는 메모리를 줄이는데 도움이 된다. 다만, 이 접근 방식의 단점은, 정적 메모리 크기를 증가시킨다.

작성자: Subin
참고: https://blog.naver.com/techref/222251293739