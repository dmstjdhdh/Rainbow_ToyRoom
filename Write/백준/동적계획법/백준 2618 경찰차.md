## 문제

어떤 도시의 중심가는 N개의 동서방향 도로와 N개의 남북방향 도로로 구성되어 있다.

모든 도로에는 도로 번호가 있으며 남북방향 도로는 왼쪽부터 1에서 시작하여 N까지 번호가 할당되어 있고 동서방향 도로는 위부터 1에서 시작하여 N까지 번호가 할당되어 있다. 또한 동서방향 도로 사이의 거리와 남 북방향 도로 사이의 거리는 모두 1이다. 동서방향 도로와 남북방향 도로가 교차하는 교차로의 위치는 두 도로의 번호의 쌍인 (동서방향 도로 번호, 남북방향 도로 번호)로 나타낸다. N이 6인 경우의 예를 들면 다음과 같다.

![[Pasted image 20231020162813.png]]

이 도시에는 두 대의 경찰차가 있으며 두 차를 경찰차1과 경찰차 2로 부른다. 처음에는 항상 경찰차1은 (1,1)의 위치에 있고 경찰차2는  (N, N)위치에 있다. 경찰 본부에서는 처리할 사건이 있으면 그 사건이 발생된 위치를 두 대의 경찰차 중 하나에 알려 주고,연락 받은 경찰차는 그 위치로 가장 빠른 길을 통해 이동하여 사건을 처리한다. (하나의 사건은 한 대의 경찰차가 처리한다.) 그리고 사건을 처리 한 경찰차는 경찰 본부로부터 다음 연락이 올 때까지 처리한 사건이 발생한 위치에서 기다린다. 경찰 본부에서는 사건이 발생한 순서대로 두 대의 경찰차에게 맡기려고 한다. 처리해야 될 사건들은 항상 교차로에서 발생하며 경찰 본부에서는 이러한 사건들을 나누어 두 대의 경찰차에 맡기되, 두 대의 경찰차들이 이동하는 거리의 합을 최소화 하도록 사건을 맡기려고 한다.

예를 들어 앞의 그림처럼 N이 6인 경우, 처리해야 하는 사건들이 3개 있고 그 사건들이 발생된 위치를 순서대로 (3,5), (5,5), (2,3)이라고 하자. (3,5)의 사건을 경찰차2에 맡기고 (5,5)의 사건도 경찰차 2에 맡기며, (2,3)의 사건을 경찰차1에 맡기면 두 차가 이동한 거리의 합은 4 + 2 + 3 = 9가 되고, 더 이상 줄일 수는 없다.

처리해야 할 사건들이 순서대로 주어질 때, 두 대의 경찰차가 이동하는 거리의 합을 최소화 하도록 사건들을 맡기는 프로그램을 작성하시오.


## 입력

첫째 줄에는 동서방향 도로의 개수를 나타내는 정수 N(5 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 처리해야 하는 사건의 개수를 나타내는 정수 W(1 ≤ W ≤ 1,000)가 주어진다. 셋째 줄부터 (W+2)번째 줄까지 사건이 발생된 위치가 한 줄에 하나씩 주어진다. 경찰차들은 이 사건들을 주어진 순서대로 처리해야 한다. 각 위치는 동서방향 도로 번호를 나타내는 정수와 남북방향 도로 번호를 나타내는 정수로 주어지며 두 정수 사이에는 빈칸이 하나 있다. 두 사건이 발생한 위치가 같을 수 있다.

## 출력

첫째 줄에 두 경찰차가 이동한 총 거리를 출력한다. 둘째 줄부터 시작하여 (i+1)번째 줄에 i(1 ≤ i ≤ W)번째 사건이 맡겨진 경찰차 번호 1 또는 2를 출력한다.

## 예제 입력1

```c
6
3
3 5
5 5
2 3
```

## 예제 출력1

```c
9
2
2
1
```


## 상태 결정

### 상태란?

'상태'는 점화식의 일반항을 말하며, 위에서 이야기한 '부분 문제'와도 같은 의미이다.
즉, DP 정의에서 나온 '동일한 부분 문제'로 나누는 것이 DP 문제를 푸는 첫 단계이다. 상태를 나눌 때는 index가 포함된 Subtask로 나누기 위해 노력하면 좋다.

>Tip.
>문제의 형태를 "A일 때 B한 C값을 찾아라" 라고 바꾼 뒤,
>A를 index로 잡고 생각해보기.
>또한 문제에서 최종적으로 요구하는 C가 무엇인지 확인하고, C는 최종 답안이며, 이는 마지막 index의 Subtask 결과값을 의미한다.

### 피보나치 수열 예시

피보나치 수열에서 19837번째 수를 구해보자.
이 문제는 "n이 19837일 때 피보나치 수열에서 n번째 수를 찾아라"라고 바꿀 수 있다. 위에서 말한 팀에서, n이 19837일때 -> index. 피보나치 수열에서 n번째한 , 수 -> C를 찾아라. 로 이해하면 될 듯 하다.

### 경찰차 문제에서는?

경찰차 문제는 "n번째 사건까지 처리했을 때 두 경찰차의 이동거리 합의 최솟값을 찾아라"라고 바꿀 수 있다.

A : n번째 사건까지 처리했을 때 -> index
B: 두 경찰차 사이의 이동거리의 합
C: 의 최솟값 -> Subtask 결과값.

으로 이해하고 점화식을 이제 만들어보자.

## 점화식 만들기

앞서 결정된 상태들 간의 관계를 찾아 점화식을 만들어보자.

> 보통 B가 관계의 힏트가 되고, DP는 memoization을 사용하는 기법이므로, 특정 상태의 값을 결정할 때 이전 상태의 값을 어떻게 활용할 수 있는지 생각해보자.

### 경찰차

n번째 사건까지 처리했을 때 두 경찰차의 이동거리 합의 최솟값을 찾아라.
라는 문제에서 누적합이라는 점에 착안하여 아래와 같이 관계식을 나타내보자.

$A_i$ $=$ $A_{i-1}$ $+$ $X$ 
$X$ : $n$번째 사건을 처리할 때 이동한 거리


## 구현

### Dp를 구현하는 두 가지 방법

Dp를 구현하는 두 가지 방법으로 Top-Down 방식과 Bottom-Up 방식이 있다. 피보나치 예시 코드를 작성해보자.

### Top-Down

```c
#include <iostream>
#include <vector>
using namespace std;

const int n = 5;
vector<int> D(n + 3, -1);

int fibonacci(int num) {
    if (D[num] != -1) {
        return D[num];
    }
    if (num <= 2) {
        D[num] = 1;
        return D[num];
    }

    D[num] = fibonacci(num - 1) + fibonacci(num - 2);
    return D[num];
}

int main() {
    cout << fibonacci(n);
    return 0;
}

```

 - 재귀 함수와 메모이제이션을 사용하여 DP 문제를 해결.
 - 문제를 작은 부분으로 나누고, 각 문제를 해결하는 동안 중간 결과를 저장. (메모이제이션)
 - 이전에 계산한 결과를 활용해서, 중복계산을 피함.
 - 직관적이나, 재귀 호출 오버플로우의 가능성이 있으며, 초기화와 재귀 호출 순서에 주의해야한다.
### Bottom-Down

```c
#include <iostream>
#include <vector>
using namespace std;

const int n = 5;
vector<int> D(n + 3, -1);

int main() {
    D[1] = 1;
    D[2] = 1;
    for (int i = 3; i <= n; i++) {
        D[i] = D[i - 1] + D[i - 2];
    }

    cout << D[n] << endl;
    return 0;
}
```

 - 작은 부분의 문제부터 시작, 모든 중간 결과를 순차적으로 계산하는 방식.
 - 일반적으로 반복문을 사용함
 - 초기상태에서부터 시작해서 점진적으로 해를 구함
 - 보통 메모리 사용량이 적고 Top-Down보다 빠른 시행시간. 스택오버플로우 문제 없음.

이름 그대로 어느 일반항부터 계산할지에 따라 두 가지 방법으로 구현이 가능. 하지만 모든 DP문제에서 이 두가지 방법을 사용할 수 있는 것은 아니며, 문제에 따라서 어떤 구현이 좋을지 익혀야 한다.

### 경찰차

$A_i$ $=$ $A_{i-1}$ $+$ $X$ 
$X$ : $n$번째 사건을 처리할 때 이동한 거리

앞서 세운 점화식을 구현하기 위한 방법을 생각해보자. 문제 해석에 따라서, 점화식은 두 가지로 존재하게 된다.

$A_i$ $=$ $A_{i-1}$ $+$ $X1$ 
$X1$ : $n$번째 사건을 경찰차1이 처리할 경우 이동거리

$A_i$ $=$ $A_{i-1}$ $+$ $X2$ 
$X2$ : $n$번째 사건을 경찰차2가 처리할 경우 이동거리

X1과 X2는 경찰차 1,2가 각각 n-1번째 사건 처리 직후 어느 좌표에 있는지 알아야 계산이 가능하다.

but.
만약 경찰차1이 n-1번째 사건을 처리했을 때 경찰차2가 마지막으로 처리한 사건을 몇 번째 일까? 1~n-2까지 n-2개의 경우의 수가 가능하다. 경찰차 2도 마찬가지이고, 이런 경우의 수가 존재하는데 반복문을 시행하여 조사하는 것은, 시간복잡도 측면에서 좋지 않다.

#### Bottom-Down 방식의 접근

두 경찰차가 마지막으로 처리한 사건이 몇 번째인지 알아두는 것이 중요하다.

$dp[x][y]$ = 경찰차1은 x번째 사건, 경찰차2는 y번째 사건을 마지막으로 처리했을 때 두 경찰차의 이동거리 최소합으로 정의.

$dp[0][0]$ 은, 아무 사건도 처리하지 않았으니 값은 0. 그리고, x번째 사건과 y번째 사건의 값은 같을 수 없고, 둘 중 더 큰 값이 마지막으로 처리된 사건의 번호이다. 다음에 진행되는 사건의 번호는, "x,y중 더 큰 값 + 1"으로 처리가 가능하다.

##### 경찰차1이 다음 사건을 처리하는 경우
$dp[x][y] + distance(x,max(x,y) + 1) = dp[max(x,y)+1][y]$ 

##### 경찰차2가 다음 사건을 처리하는 경우
$dp[x][y] + distance(y,max(x,y) + 1) = dp[x][max(x,y)+1]$ 

이 점화식을 갖고,  N x N 크기의 2차원 배열 Dp를 순회하며 값을 채워나가면 된다.

## 최종 코드

```c
#include <iostream>
#include <cmath>
#include <memory.h>
using namespace std;

int n, m;
int dp[1001][1001];
int arr[1001][1001];
pair<int, int> pos[1001];

int distance_pair(pair<int,int> a, pair<int,int> b) {
    return abs(a.first - b.first) + abs(a.second - b.second);
}

int operationA(int x, int y) {
    int nidx = max(x,y) + 1;
    if(nidx == m+2) return 0;
    
    if(dp[x][y] != -1) return dp[x][y];
    
    int xsolve = operationA(nidx, y) + distance_pair(pos[x], pos[nidx]);
    int ysolve = operationA(x, nidx) + distance_pair(pos[nidx], pos[y]);
    
    if(xsolve > ysolve) {
        dp[x][y] = ysolve;
        arr[x][y] = 1;
    } else dp[x][y] = xsolve;
    
    return dp[x][y];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    memset(dp, -1, sizeof(dp));
    memset(arr, 0, sizeof(arr));
    
    cin >> n;
    cin >> m;
    
    pos[0] = {1,1};
    pos[1] = {n,n};
    
    for(int i = 2; i<m+2; ++i) {
        cin >> pos[i].first >> pos[i].second;
    }
    
    cout << operationA(0,1) << "\n";
    
    int x = 0, y = 1;
    while(max(x,y)+1 != m+2) {
        
        cout << arr[x][y]+1 << '\n';

		if(arr[x][y]) y = max(x,y)+1;
		else x = max(x,y)+1;
    }
}
```

작성자 : Subin
참고 글 : https://velog.io/@hoonww/DP%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-%EB%B0%8F-%ED%99%9C%EC%9A%A9