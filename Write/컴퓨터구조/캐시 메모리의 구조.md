## Cache

캐시 메모리 (Cache Memory)는 CPU 프로페서가 빠른 속도로 데이터를 주고 받을 수 있도록 도와주는 메모리이다. 

> 이를 위해서 캐시 메모리는 CPU 프로세서와 인접하게 위치하고 있다.


## Cache Blocks

캐시 메모리는 캐시 블록이라는 데이터 그룹 단위를 가진다.
각각의 캐시 블록은 데이터를 담고 있으며, Cache Tag와 묶어서 하나의 Cache Entry를 구성한다. Tag는 캐시 블록의 고유 식별값으로 CPU 프로세서는 캐시 태그 값을 통해 캐시 블록에 접근이 가능하다.

캐시 태그에는 해당 캐시 블록에 올바른 데이터가 저장되어있다는 것을 나타내는 유효 비트가 포함되어 있다. 만약 올바르지 못한 값이라면, 유효비트는 0으로 설정된다.

캐시가 빠른 이유는, 참조 지역성의 원리에 따라, 자주 사용하는 데이터를 우선적으로 저장하고 있기 때문이기도 하지만, 유효비트와 태그필드를 이용한 메모리 접근으로 인해, 시간복잡도가 O(1)일 정도로 작아지기 때문이기도 하다.

![[Pasted image 20231024023959.png]]

캐시 메모리는 S개의 집합으로 묶여있으며, 각 집합은 E개의 캐시 엔트리를 가지고 있는 캐시라인으로 구성된다. 필요한 캐시 메모리의 크기는 메모리에 존재하는 캐시 블록의 전체 개수와 블록 하나당의 크기로 계산한다.

>태그필드와 유효비트를 가지고 있는 캐시 태그는 필요한 캐시 메모리의 크기와는 별도의 요구되는 공간이다. 또한 이후에 이야기할 인덱스 필드의 경우에도 캐시 메모리 크기에 영향을 주지 않는다. 인덱스 필드는 별도의 비트 필드를 가지지 않아도 하드웨어에서 물리적인 주소로 바로 연결을 시켜준다.



### 예시

 - 32KB 캐시라는 말은 32KB 데이터를 저장할 수 있는 캐시 메모리라는 의미이다.


## Memory Access

CPU 프로세서는 필요한 데이터가 있을때마다 해당 데이터의 메모리 주소를 이용하여 액세스한다. 하드웨어 장치에서 물리적인 메모리 주소를 바로 연결을 시켜주기 때문에 메모리 주소는 별도의 메모리 공간을 가지지 않는다. 참고로 캐시 메모리는 사용자 프로그램과 메모리 저장소에 대하여 투명하게 동작하므로, 프로그래머가 캐시 메모리를 고려하여 코드를 작성할 필요가 없다.

> 캐시 메모리의 투명성 또한, note로 정리되어있다.

찾고 있는 데이터의 메모리 주소는 먼저 캐시 메모리에서 이용된다. 메모리 주소를 이용하여 찾고 있는 데이터가 캐시 블록에 있는지 여부를 식별하는데 사용한다. Cache Hit(캐시 히트)는 캐시 메모리에 찾는 데이터가 존재하였을 때를 나타내며, Cache Miss(캐시 미스)는 캐시 메모리에 찾는 데이터가 존재하지 않음을 나타낸다. Cache Miss가 발생하면, 메모리 저장소로부터 필요한 데이터를 찾아 캐시 메모리에 로드한다.

메모리 주소는 올바른 캐시 블록을 식별할 수 있도록 캐시 태그 (Cache Tag), 세트 인덱스 (Set Index) 그리고 블록 오프셋 (Block Offset)으로 구성된다. 블록 오프셋은 캐시 블록 내의 특정 바이트 위치에 액세스하기 위한 필드이다.

![[Pasted image 20231024161030.png]]

캐시 히트와 캐시 미스의 판정은, CPU 프로세서에서, 액세스 예정인 메모리 주소를 참고해서, 캐시 메모리의 엔트리를 검사한다.

 - 먼저 세트 인덱스(Set Index)에 따른 캐시 엔트리 (Cache Entry)에 액세스한다.
 - 해당 캐시 엔트리의 유효 비트가 1인지 확인한다.
 - 유효 비트가 1이라면, 메모리 주소의 태그 필드와 캐시 엔트리의 태그 필드가 동일한지 비교한다.
 - 두 개의 태그가 동일하면, 유효 비트와 AND 연산한다.

즉, 유효비트가 1인 경우와 0인 경우를 Cache Hit, Cache Miss로 이해하면 된다. 하지만 유효비트가 1이라도, 태그가 서로 일치하지 않으면 Cache Miss가 발생하게 된다. 이 경우, 캐시 메모리의 교체 정책에 따라 조치가 이루어진다. 선입 선출 정책을 사용하고 있다면, 가장 오래된 데이터가 가장 면저 교체된다던가 하는 것이다.

작성자 : Subin
참고 : https://blog.naver.com/PostView.nhn?blogId=techref&logNo=222290234374