개발을 하다보면 팀원들과 언어나 프레임워크의 버전이 달라서 오류가 나는 경우가 꽤 많은 것 같다.

최근 팀 단위로 일을 시작하게 된 곳에서도, 파이썬 버전이 달라서 이슈가 많다는 상황이 생기기도 했다. 실제 프로젝트에 적용은하지 못했지만, "이러한 상황에서 이점을 가질 수 있는 기술이 뭐가있을까?" 하는 생각에 찾아보다가, Docker와 가상화에 대해서 알아보게 되었다.

# Docker란?

![](https://velog.velcdn.com/images/dmstjdhdh/post/9cde3585-7941-408e-88cc-0de24ceaa11a/image.png)

Docker는 리눅스 환경에서 시작한 컨테이너 가상화 플랫폼으로, 컨테이너 기술의 선두 주자 중 하나이다. Docker는 컨테이너를 생성, 배포 및 실행하기 위한 도구와 플랫폼을 제공하며, 다른 운영체제와도 통합되어 사용할 수 있다. Go 언어로 작성되었다고 한다.

# 가상화가 뭐지?

## 정의

가상화를 한 번에 이해하기는 너무 어려웠다.
AWS에서 정의하는 가상화는 다음과 같았다.

> 가상화는 서버, 스토리지, 네트워크 및 기타 물리적 시스템에 대한 가상 표현을 생성하는 데 사용할 수 있는 기술입니다. 가상 소프트웨어는 물리적 하드웨어 기능을 모방하여 하나의 물리적 머신에서 여러 가상 시스템을 동시에 실행합니다. 기업은 가상화를 사용해 하드웨어 리소스를 효율적으로 사용하여 투자 대비 이익을 더 많이 얻을 수 있습니다. 또한 클라우드 컴퓨팅 서비스를 지원하여 조직의 인프라를 더욱 효율적으로 관리할 수 있습니다.

가상화를 사용한다면, 하드웨어 리소스를 효율적으로 사용할 수 있다는데... 사실 저 글 하나만으로는 이해하기 힘들어서 여러 글들을 더 찾아보았다.

## 가상화 등장의 배경

1960~1970년대에는, 하드웨어의 성능이 빠르게 증가는데에 비해서 소프트웨어의 발전 속도는 이를 따라가지 못했다고 한다.

![[Pasted image 20231111170759.png]]

이때에는 소프트웨어를 실행하면 서버 성능이 소프트웨어에서 요구하는 서버 사양에 비해서 훨씬 좋아서, 서버의 성능을 다 사용하지 못하는 비효율이 발생하였다고 한다. 비싼 컴퓨터를 사서 서버를 구축했는데... 성능대비 20~30%의 자원만 사용할 수 있다는 것은 비효율적인 상황이였을 것 같다.

> 만약 이 서버를 가상화하여 두~세 대의 서버처럼 사용할 수 있다면 어떨까?

내가 만약 용도가 다른 서버가 여러개가 있을 때, 이러한 아이디어는 컴퓨팅 자원 활용의 비효율 문제를 해결할 수 있을 것 같다.

이 아이디어를 통해서, 1960년에 가상화를 구현한 최초의 하이퍼바이저(가상화 구현해주는 OS)인 CP-40이 개발되었다고 한다. 

## Virtual Machine

가상화의 구현에 따라서, Virtual Machine (줄여서 VM) 이 등장하고, 이를 생성하고 배포할 수 있는 다양한 솔루션이 등장하게 된다. VM은 OS를 가지고 있는 가상 컴퓨팅 환경이다.

조금 어려운 말은, 조금 더 쉬운말로 바꿔볼 수 있을 것 같다. 컴퓨터 안에서 또 다른 컴퓨터를 동작시키는 방식을 VM이라고 이해할 수 있고, 이를 사용한다는 것은 컴퓨터 시스템을 에뮬레이션 한다고 말할 수 있다.

물리적으로 존재하는 컴퓨터는 아니나, 우리는 VM을 통해서 실제 컴퓨터처럼 작동시킬 수 있다. 이는 서버의 가상화에 사용되었고, 하나의 컴퓨터 자원을 여러 사용자에게 효율적으로 나눠줄 수 있는 방식이 되었다.


![[Pasted image 20231111173151.png]]

VM에 등장으로 인해서, 다음과 같은 효과를 가져오게 되었다.
- 적은 비용으로 더 많은 가치를 창출할 수 있으며
- 복잡성이 줄어들고
- 더욱 신속하게 유지관리가 가능해진다.
## 컨테이너의 등장

VM 사용 자체에도, 비용 절감이 가능하고 컴퓨터의 효율성이 높아지기 때문에, 대부분의 기업들이 VM을 사용하기 시작하였는데, 2010년 이후에 컨테이너라는 개념이 도입되기 시작한다.

컨테이너는 소프트웨어 응용 프로그램과 그 실행 환경을 패키지화하고 격리된 환경에서 실행할 수 있도록 하는 가상화 기술의 한 형태이다. 위에서 언급한 VM과 달리, OS를 포함하지는 않는다. 

VM과 다르게, 가볍고, 배포가 빠르며, 자원을 더 효율적으로 관리할 수 있는 특징을 가지고 있다. 하나의 컨테이너를 사용해서, 마이크로서비스부터 거대한 어플리케이션까지 모든 것을 실행할 수 있게 되었다.

이러한 컨테이너를 배포할 수 있는 플랫폼이 Docker인 것이다. (Kubernetes 라는 배포 플랫폼도 있다고 한다.)

### 컨테이너 동작 방식

컨테이너는 특정 프로그램을 실행하기 위해서

- 운영 체제
- 지원 프로그램 및 라이브러리
- 시스템 리소스

가 필요하다. 이 구성요소들은 컨테이너 내부에서 작업할 때, 필요한 환경의 템플릿을 만들게 해준다. 

#### 이미지

도커에서는, 이렇게 컨테이너를 실행하기 위해서 필요한 시스템을 "이미지"라고 정의한다. 이 이미지는 도커 엔진에 의해서 실행되는 도커 컨테이너의 기반을 형성하며, 애플리케이션을 패키징하고 배포하는데 사용된다.

# Instruction

Docker에서의 Instruction을 가볍게 알아보면서, 컨테이너를 실행해보고자 한다.

## FROM
- 'FROM' 명령어는 기본 이미지를 지정하는 명령어이다.
- Docker 이미지는 기본 이미지 위에 추가적인 레이어를 쌓아서 구성된다. 'FROM' 명령어는 이 이미지의 기반이 될 이미지를 지정한다.
- 예를 들어, 'python:3.8'은 Python 3.8을 설치한 공식 Python 이미지를 사용한다는 것을 의미한다. Docker Hub와 같은 공개 레스트리에서 이미지를 가져올 수도 있고, 로컬에 직접 빌드한 이미지를 사용할 수도 있다.

```javascript
FROM python:3.8
```

## RUN

- 'RUN' 명령어는 Docker 이미지 내에서 실행할 명령을 지정하는 명령어이다.
- Dockerfile에서 RUN으로 지정한 명령은 이미지를 빌드하는 과정중에 컨테이너 내에서 실행된다.
- 예를 들어, 'RUN pip install somepackage'는 이미지를 빌드할 때 컨테이너 내에서 'somepackage' 패키지를 설치하는 명령어이다.

```javascript
RUN pip install pyside6
```

## WORKDIR

- 'WORKDIR' 명령어는 작업 디렉토리를 설정하는 명렁어이다.
- 컨테이너 내에서 어떤 디렉토리에서 명령을 실행할 것인지 지정한다. 즉, 작업 디렉토리를 변경한다.
- 예를 들어서, 'WORKDIR / app' 명령어는 컨테이너 내에서 모든 후속 명령이 '/app' 디렉토리에서 실행됨을 의미한다.

```javascript
WORKDIR /app
```

## ADD
- 'ADD' 명령어는 로컬 파일 및 URL에서 파일을 복사하는 데 사용된다.
- 'ADD' 명령어는 'COPY'랑 다르게 파일의 자동 압축 해체, URL 에서 자동 다운로드 및 자동 압축 해제 등을 수행할 수 있다.

## COPY

- 'COPY' 명령어는 로컬 파일 또는 디렉토리를 컨테이너에 복사하는 데 사용된다.
- 'COPY'는 단순히 복사하며, 추가 작업을 수행하지 않는다. ADD와 같이 URL 에서 자동 다운로드 및 자동 압축 해제를 수행하지 않는다는 것이다.

```javascript
WORKDIR /app
COPY file.txt /app/
ADD https://example.com/archive.zip/app/
```

위 코드에서와 같이 ADD는 복사 및 압축 해제 작업이 필요할 때, URL에 접근할 때 사용하는 것을 권장하며, COPY는 간단한 파일 복사에 사용된다.

## EXPOSE

- EXPOSE는 컨테이너가 외부와 통신할 포트를 지정하는 명렁어이다.

## ENV

- ENV는 역시 환경 변수를 설정하는 명령어이다.

## CMD

- CMD 명령어는 컨테이너가 시작될 때 실행할 기본 명령을 정의한다.

```javascript
CMD ["python", "main.py"]
```

컨테이너가 실행될 때, python main.py가 시행된다.

# Build

Dockerfile을 사용해서, Docker 이미지를 빌드하고 그 이미지를 실행가능한 Docker 컨테이너로 만들기 위해서는 'docker build' 및 'docker run' 명령어를 사용한다.

## 이미지 빌드 (docker build)

- 'docker build' 명령어는 Dockerfile을 사용하여 Docker 이미지를 빌드하는 데 사용된다.

다음은 Docker 이미지 빌드 명령어의 예제 구문이다.

```
docker build -t (이미지 이름 태그) (경로 혹은 URL)
```

- '-t' 옵션은, 이미지에 이름과 태그를 부여하는 역할을 한다. 

예를들어 Dockerfile이 현재 디렉토리에 있고 이미지 이름을 "my-python-app"으로 하려면 다음과 같이 명령어를 사용할 수 있다.

```
docker build -t my-python-app .
```

## 컨테이너 실행 (docker run)

- docker run 명령어는 Docker 이미지를 실행 가능한 컨테이너로 시작하는데 사용된다.

기본 명령은 다음과 같다.

```
docker run (옵션) (이미지 이름 태그) (실행 명령)
```

- 옵션은 컨테이너 실행을 구성하는 여러 가지 옵션을 나타내고, 포트 매핑, 환경 변수 설정 등을 지정할 수 있다.
- 실행 명령은 컨테이너가 시작될 때 실행할 명령을 나타낸다. 추가적인 명령은 dockerfile 내에서 CMD 명령을 통해서 실행할 수 있다.

예를들어서, 이미지 'my-python-app"을 실행하고 호스트의 포트 4000을 컨테이너의 포트 80으로 매핑하려면 다음 명령어를 사용할 수 있다.

```
docker run -p 4000:80 my-python-app
```

# 파일 생성

![](https://velog.velcdn.com/images/dmstjdhdh/post/1b78ba51-c45f-4f88-b6e2-8e758e454085/image.png)

main.py와 docker.dockerfile을 생성한 후에,

![](https://velog.velcdn.com/images/dmstjdhdh/post/d81daf73-6a66-4cbc-8bf2-9941e7af9055/image.png)

main.py에는, kiwi라는 api를 사용하는 코드를 작성했다. 해당 api는 

```python
pip install kiwipiepy
```

를 설치하여 사용해야하는 api인데, 이런식으로 문장에서 형태소 하나하나를 추출해내는 기능을 가지고 있다.
![](https://velog.velcdn.com/images/dmstjdhdh/post/5d83f640-1f4b-4554-b574-3a1a7bd96fa3/image.png)

dockerfile에는 다음과 같이 코드를 작성해주고
![](https://velog.velcdn.com/images/dmstjdhdh/post/3269f27d-ce0d-4a1b-ac7f-49506b5ec10b/image.png)
```
docker build -t kiwi-app .
```
명령어를 시행해주면, 터미널에서 이미지가 생성되는걸 볼 수 있다.


![](https://velog.velcdn.com/images/dmstjdhdh/post/27d58e64-74c2-45a2-9c7e-12d18a2efe93/image.png)

Docker Desktop 프로그램 내에서, 정상적으로 내가 생성한 Image가 등록되어있는걸 볼 수 있었다.

![](https://velog.velcdn.com/images/dmstjdhdh/post/4ee0c87d-16c0-429a-a04d-6d570442d947/image.png)

해당 Image를 컨테이너화 해서, 시행시켜주면

![](https://velog.velcdn.com/images/dmstjdhdh/post/fc1dcc50-a451-41a0-b9dc-abb52e344e29/image.png)

가상환경에서, 문제없이 해당 기능이 시행되는걸 볼 수 있었다. 당시에 내 컴퓨터에는 kiwipiepy라는 모듈이 다운로드되어있지 않는 상황이였기 때문에, 정상적으로 컨테이너가 실행되는걸 볼 수 있었다.

