C++에서 알고리즘을 풀 때에 실행 속도를 높이기 위한 구문들이 있다.
이 구문들에 대하여 친구가 의문을 가졌기에 정리를 해보았다.
## ios_base::sync_with_stdio(false);

ios_base::sync_with_stdio(false);는 c의 stdio와 cpp의 iostream을 동기화시켜주는 역할을 한다. 

그런데 이 순간 iostream과 stdio의 버퍼[^각주1]를  모드 사용하기에 딜레이가 발생하게 된다.

따라서  ios_base::sync_with_stdio(false); 코드를 작성하여 동기화를 비활성화한다. 

 ios_base::sync_with_stdio(false); 코드를 작성하면, cin과 cout의 묶임이 false로 바뀜으로써, cpp 컴파일러가 c와 cpp 스타일의 입출력 혼용을 허용하는 것을 구현하기 위한 동기화를 끄게 만든다. 그렇게 독립된 자신만의 버퍼를 사용할 수 있게 한다. 

그렇게 cpp만의 독립적인 버퍼가 생성되어 c의 버퍼와 병행하여 사용할 수 없게 되지만 그렇기에 사용하는 버퍼의 수가 줄어들어 실행 속도가 빨라지는 결과를 가져오게 됐다.

하지만 동기화된 cpp버퍼의 경우 thread-safe[^각주2]하기 때문에 모든 I/O(입력/출력) 순서가 예상한 것과 정확히 일치함을 보장할 수 있지만  ios_base::sync_with_stdio(false); 코드를 추가하여 동기화가 비활성화 되었기 때문에 멀티 스레드 환경에서는 출력 순서를 보장할 수 없다. 

또한 버퍼가 분리되었으므로, cin과 C의 scanf, gets, getchar 등을 같이 사용하거나, cout와 C의 printf, puts, putchar등을 사용하면 오류가 발생한다.


## cin,tie(null), cout.tie(null)

기본적으로, cin과 cout은 묶여있다. 묶여있다는 것은 두 개의 스트림[^각주3]이 싱크되어 있기 때문에 한 스트림에서 다른 스트림이 작업 요청을 하게 되면,  flush[^각주4]한다는 것이다.

그렇기에 cin.tie(null)를 사용하면  cin과 cout의 묶음을 해제하게 되고, flush의 빈도가 떨어지기 때문에 입출력 속도가 빨라진다.

보통 묶여있는 스트림들은 한 스트림이 다른 스트림에서 각 IO 작업을 진행하기 전, 자동으로 버퍼를 비워준다.

```cpp
cout << "게임을 선택: ";
cin >> game;
```


위 코드를 보면,  cin과 cout이 묶여있어 게임을 선택하기 전에 "게임을 선택"이 먼저 출력될 것이다. 하지만 cin.tie(null); 코드를 추가하면 묶음이 풀리며 "게임을 선택"이 출력되기도 전에 먼저 게임을 입력받게 되는 경우가 발생할 수 있다.

cout이 기본적으로 버퍼에 추가되고 바로 비워지지 않았기 때문이다. 
 (버퍼는 출력 명령을 내리거나 버퍼가 가득 찼을 경우에만 비워지게 됨.)

따라서 cin.tie(null); 코드를 추가했고 game을 입력받기 전에 "게임을 선택" 구문을 먼저 출력하고 싶다면 cout으로 구문을 출력할 때 버퍼를 비워주어야 한다.


## 결론

 -알고리즘 문제를 풀 때에는 웬만하면 싱글 스레드 환경이기에ios_base::sync_with_stdio(false);
 코드를 추가해도 결과에 영향이 없고, c와 cpp의 버퍼를 분리하기에 실행 속도가 빨라짐.
  하지만 이때 c스타일의 입출력을 혼용하지 않도록 해야함.

  -cin.tie(null), cout.tie(null)을 사용하면 flush가 적어지기 때문에 입출력 속도가 빨라진다.
   입력 출력 각각 순서는 보장되지만, 입출력의 순서는 보장될 수 없다.



작성자 - hyisu

---
[^각주1] 데이터를 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역

[^각주2] 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음.

[^각주3] 실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름을 의미

[^각주4] 버퍼에 쌓아둔 데이터를 전부 가져오는 것